
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/cryjngblxxd/scripts/refs/heads/main/UTOPIA"))()

local RunService = game:GetService("RunService")
local players = game:GetService("Players")
local workspace = game:GetService("Workspace")
local plr = players.LocalPlayer
local camera = workspace.CurrentCamera
local mouse = plr:GetMouse()



local hue = 0
local rainbowFov = false
local rainbowSpeed = 0.005

local aimFov = 100
local aiming = false
local predictionStrength = 0.065
local smoothing = 0.05

local aimbotEnabled = false
local wallCheck = true
local stickyAimEnabled = false
local teamCheck = false
local healthCheck = false
local minHealth = 0

local circleColor = Color3.fromRGB(255, 0, 0)
local targetedCircleColor = Color3.fromRGB(0, 255, 0)



local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.Radius = aimFov
fovCircle.Filled = false
fovCircle.Color = circleColor
fovCircle.Visible = false

local currentTarget = nil



local function checkTeam(player)
    if teamCheck and player.Team == plr.Team then
        return true
    end
    return false
end

local function checkWall(targetCharacter)
    local targetHead = targetCharacter:FindFirstChild("Head")
    if not targetHead then return true end

    local origin = camera.CFrame.Position
    local direction = (targetHead.Position - origin).unit * (targetHead.Position - origin).magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {plr.Character, targetCharacter}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = workspace:Raycast(origin, direction, raycastParams)
    return raycastResult and raycastResult.Instance ~= nil
end

local function getTarget()
    local nearestPlayer = nil
    local shortestCursorDistance = aimFov
    local shortestPlayerDistance = math.huge
    local cameraPos = camera.CFrame.Position

    for _, player in ipairs(players:GetPlayers()) do
        if player ~= plr and player.Character and player.Character:FindFirstChild("Head") and not checkTeam(player) then
            if player.Character.Humanoid.Health >= minHealth or not healthCheck then
                local head = player.Character.Head
                local headPos = camera:WorldToViewportPoint(head.Position)
                local screenPos = Vector2.new(headPos.X, headPos.Y)
                local mousePos = Vector2.new(mouse.X, mouse.Y)
                local cursorDistance = (screenPos - mousePos).Magnitude
                local playerDistance = (head.Position - cameraPos).Magnitude

                if cursorDistance < shortestCursorDistance and headPos.Z > 0 then
                    if not checkWall(player.Character) or not wallCheck then
                        if playerDistance < shortestPlayerDistance then
                            shortestPlayerDistance = playerDistance
                            shortestCursorDistance = cursorDistance
                            nearestPlayer = player
                        end
                    end
                end
            end
        end
    end

    return nearestPlayer
end

local function predict(player)
    if player and player.Character and player.Character:FindFirstChild("Head") and player.Character:FindFirstChild("HumanoidRootPart") then
        local head = player.Character.Head
        local hrp = player.Character.HumanoidRootPart
        local velocity = hrp.Velocity
        local predictedPosition = head.Position + (velocity * predictionStrength)
        return predictedPosition
    end
    return nil
end

local function smooth(from, to)
    return from:Lerp(to, smoothing)
end

local function aimAt(player)
    local predictedPosition = predict(player)
    if predictedPosition then
        if player.Character.Humanoid.Health >= minHealth or not healthCheck then
            local targetCFrame = CFrame.new(camera.CFrame.Position, predictedPosition)
            camera.CFrame = smooth(camera.CFrame, targetCFrame)
        end
    end
end



RunService.RenderStepped:Connect(function()
    if aimbotEnabled then
        local offset = 50
        fovCircle.Position = Vector2.new(mouse.X, mouse.Y + offset)

        if rainbowFov then
            hue = hue + rainbowSpeed
            if hue > 1 then hue = 0 end
            fovCircle.Color = Color3.fromHSV(hue, 1, 1)
        else
            if aiming and currentTarget then
                fovCircle.Color = targetedCircleColor
            else
                fovCircle.Color = circleColor
            end
        end

        if aiming then
            if stickyAimEnabled and currentTarget then
                local headPos = camera:WorldToViewportPoint(currentTarget.Character.Head.Position)
                local screenPos = Vector2.new(headPos.X, headPos.Y)
                local cursorDistance = (screenPos - Vector2.new(mouse.X, mouse.Y)).Magnitude

                if cursorDistance > aimFov or (wallCheck and checkWall(currentTarget.Character)) or checkTeam(currentTarget) then
                    currentTarget = nil
                end
            end

            if not stickyAimEnabled or not currentTarget then
                currentTarget = getTarget()
            end

            if currentTarget then
                aimAt(currentTarget)
            end
        else
            currentTarget = nil
        end
    end
end)

mouse.Button2Down:Connect(function()
    if aimbotEnabled then
        aiming = true
    end
end)

mouse.Button2Up:Connect(function()
    if aimbotEnabled then
        aiming = false
    end
end)



local Window = Library:Window({
    Name = "Universal Aimbot",
    Size = UDim2.new(0, 500, 0, 450),
    GradientTitle = {
        Enabled = true,
        Start = Color3.fromRGB(255, 50, 50),
        Middle = Color3.fromRGB(255, 100, 100),
        End = Color3.fromRGB(255, 150, 150),
        Speed = 1
    }
})

local Watermark = Library:Watermark("Universal Aimbot | by Agreed")
local KeybindList = Library:KeybindList()



local AimbotPage = Window:Page({ Name = "Aimbot", Columns = 2 })


local MainSection = AimbotPage:Section({ Name = "Main", Side = 1 })

local AimbotToggle = MainSection:Toggle({
    Name = "Aimbot",
    Default = false,
    Flag = "Aimbot_Enabled",
    Callback = function(Value)
        aimbotEnabled = Value
        fovCircle.Visible = Value
    end
})

AimbotToggle:Keybind({
    Name = "Toggle Key",
    Default = Enum.KeyCode.E,
    Mode = "Toggle",
    Flag = "Aimbot_Keybind",
    Callback = function(Value)
        if Value then
            aimbotEnabled = not aimbotEnabled
            fovCircle.Visible = aimbotEnabled
        end
    end
})

MainSection:Slider({
    Name = "Smoothing",
    Min = 0,
    Max = 100,
    Default = 5,
    Decimals = 1,
    Suffix = "%",
    Flag = "Aimbot_Smoothing",
    Callback = function(Value)
        smoothing = 1 - (Value / 100)
    end
})

MainSection:Slider({
    Name = "Prediction Strength",
    Min = 0,
    Max = 0.2,
    Default = 0.065,
    Decimals = 0.001,
    Suffix = "",
    Flag = "Aimbot_Prediction",
    Callback = function(Value)
        predictionStrength = Value
    end
})

MainSection:Slider({
    Name = "FOV Size",
    Min = 0,
    Max = 1000,
    Default = 100,
    Decimals = 1,
    Suffix = "px",
    Flag = "Aimbot_FOV",
    Callback = function(Value)
        aimFov = Value
        fovCircle.Radius = aimFov
    end
})


local ChecksSection = AimbotPage:Section({ Name = "Checks", Side = 1 })

ChecksSection:Toggle({
    Name = "Wall Check",
    Default = true,
    Flag = "Aimbot_WallCheck",
    Callback = function(Value)
        wallCheck = Value
    end
})

ChecksSection:Toggle({
    Name = "Sticky Aim",
    Default = false,
    Flag = "Aimbot_StickyAim",
    Tooltip = "Lock onto target until out of FOV",
    Callback = function(Value)
        stickyAimEnabled = Value
    end
})

ChecksSection:Toggle({
    Name = "Team Check",
    Default = false,
    Flag = "Aimbot_TeamCheck",
    Callback = function(Value)
        teamCheck = Value
    end
})

ChecksSection:Toggle({
    Name = "Health Check",
    Default = false,
    Flag = "Aimbot_HealthCheck",
    Callback = function(Value)
        healthCheck = Value
    end
})

ChecksSection:Slider({
    Name = "Min Health",
    Min = 0,
    Max = 100,
    Default = 0,
    Decimals = 1,
    Suffix = "",
    Flag = "Aimbot_MinHealth",
    Callback = function(Value)
        minHealth = Value
    end
})

local VisualsSection = AimbotPage:Section({ Name = "FOV Visuals", Side = 2 })

local FovColorLabel = VisualsSection:Label("FOV Circle Color", "Left")
FovColorLabel:Colorpicker({
    Name = "FOV Color",
    Default = Color3.fromRGB(255, 0, 0),
    Alpha = 1,
    Flag = "Aimbot_FOVColor",
    Callback = function(Color, Alpha)
        circleColor = Color
        if not rainbowFov and not (aiming and currentTarget) then
            fovCircle.Color = Color
        end
    end
})

local TargetColorLabel = VisualsSection:Label("Targeted FOV Color", "Left")
TargetColorLabel:Colorpicker({
    Name = "Target Color",
    Default = Color3.fromRGB(0, 255, 0),
    Alpha = 1,
    Flag = "Aimbot_TargetColor",
    Callback = function(Color, Alpha)
        targetedCircleColor = Color
    end
})

VisualsSection:Toggle({
    Name = "Rainbow FOV",
    Default = false,
    Flag = "Aimbot_RainbowFOV",
    Callback = function(Value)
        rainbowFov = Value
    end
})

VisualsSection:Slider({
    Name = "Rainbow Speed",
    Min = 0.001,
    Max = 0.05,
    Default = 0.005,
    Decimals = 0.001,
    Suffix = "",
    Flag = "Aimbot_RainbowSpeed",
    Callback = function(Value)
        rainbowSpeed = Value
    end
})

VisualsSection:Slider({
    Name = "Circle Thickness",
    Min = 1,
    Max = 5,
    Default = 2,
    Decimals = 1,
    Suffix = "px",
    Flag = "Aimbot_CircleThickness",
    Callback = function(Value)
        fovCircle.Thickness = Value
    end
})

VisualsSection:Toggle({
    Name = "Filled Circle",
    Default = false,
    Flag = "Aimbot_FilledCircle",
    Callback = function(Value)
        fovCircle.Filled = Value
    end
})



local SettingsPage = Window:Page({ Name = "Settings", Columns = 2 })


local MenuSection = SettingsPage:Section({ Name = "Menu", Side = 1 })

MenuSection:Toggle({
    Name = "Show Watermark",
    Default = true,
    Flag = "Settings_Watermark",
    Callback = function(Value)
        Watermark:SetVisibility(Value)
    end
})

MenuSection:Toggle({
    Name = "Show Keybind List",
    Default = true,
    Flag = "Settings_KeybindList",
    Callback = function(Value)
        KeybindList:SetVisibility(Value)
    end
})


local ConfigSection = SettingsPage:Section({ Name = "Configuration", Side = 1 })

local ConfigListbox

local function RefreshConfigs()
    local configs = {}
    if isfolder(Library.Folders.Configs) then
        for _, file in ipairs(listfiles(Library.Folders.Configs)) do
            local fileName = file:match("([^\\]+)$")
            if fileName then
                table.insert(configs, fileName)
            end
        end
    end
    if ConfigListbox then
        ConfigListbox:Refresh(configs)
    end
end

ConfigSection:Textbox({
    Name = "Config Name",
    Placeholder = "Enter config name...",
    Default = "",
    Flag = "Settings_ConfigName",
    Callback = function(Value) end
})

ConfigSection:Button({
    Name = "Create Config",
    Callback = function()
        local name = Library.Flags["Settings_ConfigName"]
        if name and name ~= "" then
            local path = Library.Folders.Configs .. "/" .. name .. ".json"
            if not isfile(path) then
                writefile(path, Library:GetConfig())
                Library:Notification("Created config: " .. name, 3, Color3.fromRGB(0, 255, 0))
                RefreshConfigs()
            else
                Library:Notification("Config already exists!", 3, Color3.fromRGB(255, 0, 0))
            end
        else
            Library:Notification("Enter a config name!", 3, Color3.fromRGB(255, 0, 0))
        end
    end
})

ConfigListbox = ConfigSection:Listbox({
    Size = 70,
    Items = {},
    Multi = false,
    Flag = "Settings_ConfigSelected",
    Callback = function(Value) end
})

RefreshConfigs()

local SaveBtn = ConfigSection:Button({
    Name = "Save Config",
    Callback = function()
        local selected = Library.Flags["Settings_ConfigSelected"]
        if selected and selected ~= "" then
            local path = Library.Folders.Configs .. "/" .. selected
            writefile(path, Library:GetConfig())
            Library:Notification("Saved config!", 3, Color3.fromRGB(0, 255, 0))
        else
            Library:Notification("Select a config first!", 3, Color3.fromRGB(255, 0, 0))
        end
    end
})

SaveBtn:SubButton({
    Name = "Load Config",
    Callback = function()
        local selected = Library.Flags["Settings_ConfigSelected"]
        if selected and selected ~= "" then
            local path = Library.Folders.Configs .. "/" .. selected
            if isfile(path) then
                Library:LoadConfig(readfile(path))
            end
        else
            Library:Notification("Select a config first!", 3, Color3.fromRGB(255, 0, 0))
        end
    end
})

ConfigSection:Button({
    Name = "Delete Config",
    Risky = true,
    Callback = function()
        local selected = Library.Flags["Settings_ConfigSelected"]
        if selected and selected ~= "" then
            local path = Library.Folders.Configs .. "/" .. selected
            if isfile(path) then
                delfile(path)
                Library:Notification("Deleted config!", 3, Color3.fromRGB(255, 255, 0))
                RefreshConfigs()
            end
        else
            Library:Notification("Select a config first!", 3, Color3.fromRGB(255, 0, 0))
        end
    end
})

ConfigSection:Button({
    Name = "Set Auto Load",
    Callback = function()
        local selected = Library.Flags["Settings_ConfigSelected"]
        if selected and selected ~= "" then
            local name = selected:gsub(".json", "")
            Library:SetAutoLoadConfig(name)
        else
            Library:Notification("Select a config first!", 3, Color3.fromRGB(255, 0, 0))
        end
    end
})


local ThemeSection = SettingsPage:Section({ Name = "Theme", Side = 2 })

local AccentLabel = ThemeSection:Label("Accent Color", "Left")
AccentLabel:Colorpicker({
    Name = "Accent",
    Default = Library.Theme["Accent"],
    Alpha = 1,
    Flag = "Settings_ThemeAccent",
    Callback = function(Color, Alpha)
        Library:ChangeTheme("Accent", Color)
    end
})

local BgLabel = ThemeSection:Label("Background", "Left")
BgLabel:Colorpicker({
    Name = "Background",
    Default = Library.Theme["Window Background"],
    Alpha = 1,
    Flag = "Settings_ThemeBackground",
    Callback = function(Color, Alpha)
        Library:ChangeTheme("Window Background", Color)
    end
})

local TextLabel = ThemeSection:Label("Text Color", "Left")
TextLabel:Colorpicker({
    Name = "Text",
    Default = Library.Theme["Text"],
    Alpha = 1,
    Flag = "Settings_ThemeText",
    Callback = function(Color, Alpha)
        Library:ChangeTheme("Text", Color)
    end
})

ThemeSection:Dropdown({
    Name = "Preset Theme",
    Items = {"Default", "Bitchbot", "Onetap", "Aqua"},
    Default = "Default",
    MaxSize = 80,
    Flag = "Settings_ThemePreset",
    Callback = function(Value)
        local theme = Library.Themes[Value]
        if theme then
            for name, color in pairs(theme) do
                Library:ChangeTheme(name, color)
            end
            Library:Notification("Applied theme: " .. Value, 3, Color3.fromRGB(0, 255, 0))
        end
    end
})


local CreditsSection = SettingsPage:Section({ Name = "Credits", Side = 2 })

CreditsSection:Label("Universal Aimbot", "Center")
CreditsSection:Label("Original by Agreed", "Center")
CreditsSection:Label("UI: UTOPIA Library", "Center")
CreditsSection:Label("", "Center")
CreditsSection:Label("Press Z to toggle menu", "Left")
CreditsSection:Label("Hold Right Click to aim", "Left")

CreditsSection:Button({
    Name = "Unload Script",
    Risky = true,
    Callback = function()
        fovCircle.Visible = false
        fovCircle:Remove()
        Library:Notification("Unloading...", 2, Color3.fromRGB(255, 100, 100))
        task.wait(1)
        Library:Unload()
    end
})


Library:Notification("Universal Aimbot Loaded!", 5, Color3.fromRGB(0, 255, 0))
Library:Notification("Hold Right Click to aim", 5, Color3.fromRGB(255, 255, 0))


Library:TryAutoLoad()
