-- ESP Module (Optimized)
local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local function CreateESP(Config)
    local ESP = {}
    local Cache = {}
    local Friends = {}
    local Connection = nil
    local Tick = 0
    
    -- Cache frequently accessed values
    local WorldToViewportPoint = Camera.WorldToViewportPoint
    local Vector2New = Vector2.new
    local Color3New = Color3.new
    local mathClamp = math.clamp
    local mathFloor = math.floor
    local mathSin = math.sin
    local mathHuge = math.huge

    -- Update friends cache
    local function UpdateFriends()
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                pcall(function()
                    Friends[plr.UserId] = LocalPlayer:IsFriendsWith(plr.UserId)
                end)
            end
        end
    end
    task.spawn(UpdateFriends)
    Players.PlayerAdded:Connect(function(plr)
        task.delay(1, function()
            pcall(function() Friends[plr.UserId] = LocalPlayer:IsFriendsWith(plr.UserId) end)
        end)
    end)

    -- Utility functions
    local function Lerp(a, b, t)
        return a + (b - a) * mathClamp(t, 0, 1)
    end

    local function LerpColor(a, b, t)
        t = mathClamp(t, 0, 1)
        return Color3New(Lerp(a.R, b.R, t), Lerp(a.G, b.G, t), Lerp(a.B, b.B, t))
    end

    local function Gradient3(c1, c2, c3, t)
        t = mathClamp(t, 0, 1)
        return t < 0.5 and LerpColor(c1, c2, t * 2) or LerpColor(c2, c3, (t - 0.5) * 2)
    end

    local function GetAlpha(dist, maxDist, fade)
        if not fade or maxDist <= 0 then return 1 end
        local start = maxDist * 0.7
        return dist < start and 1 or mathClamp(1 - ((dist - start) / (maxDist - start)), 0.15, 1)
    end

    -- Simple box calculation (optimized - no bounding box)
    local function GetBox(char)
        local root = char:FindFirstChild('HumanoidRootPart')
        local head = char:FindFirstChild('Head')
        if not root or not head then return nil end

        local rootPos = root.Position
        local headPos = head.Position + Vector3.new(0, 0.5, 0)
        local footPos = rootPos - Vector3.new(0, 3, 0)

        local headScreen, headVisible = WorldToViewportPoint(Camera, headPos)
        local footScreen, footVisible = WorldToViewportPoint(Camera, footPos)

        if not headVisible and not footVisible then return nil end

        local top = Vector2New(headScreen.X, headScreen.Y)
        local bottom = Vector2New(footScreen.X, footScreen.Y)
        local height = bottom.Y - top.Y
        local width = height * 0.6
        local center = (top.X + bottom.X) / 2

        return {
            TL = Vector2New(center - width/2, top.Y),
            TR = Vector2New(center + width/2, top.Y),
            BL = Vector2New(center - width/2, bottom.Y),
            BR = Vector2New(center + width/2, bottom.Y),
            W = width, H = height,
            CX = center, TY = top.Y, BY = bottom.Y
        }
    end

    -- Create ESP drawings
    local function NewDraw()
        local d = {}
        
        -- Box lines (4 for full, 8 for corners)
        d.Lines = {}
        d.Outlines = {}
        for i = 1, 8 do
            d.Outlines[i] = Drawing.new("Line")
            d.Outlines[i].Visible = false
            d.Outlines[i].Color = Color3.fromRGB(0,0,0)
            d.Lines[i] = Drawing.new("Line")
            d.Lines[i].Visible = false
        end

        -- Filled box
        d.Fill = Drawing.new("Square")
        d.Fill.Visible = false
        d.Fill.Filled = true

        -- Texts
        d.Name = Drawing.new("Text")
        d.Name.Visible = false
        d.Name.Center = true
        d.Name.Outline = true
        d.Name.Font = Drawing.Fonts.System

        d.Weapon = Drawing.new("Text")
        d.Weapon.Visible = false
        d.Weapon.Center = true
        d.Weapon.Outline = true
        d.Weapon.Font = Drawing.Fonts.System

        d.Flag = Drawing.new("Text")
        d.Flag.Visible = false
        d.Flag.Center = false
        d.Flag.Outline = true
        d.Flag.Font = Drawing.Fonts.System

        -- Health bar
        d.HealthOut = Drawing.new("Line")
        d.HealthOut.Visible = false
        d.HealthOut.Color = Color3.fromRGB(0,0,0)
        d.HealthBG = Drawing.new("Line")
        d.HealthBG.Visible = false
        d.HealthFill = Drawing.new("Line")
        d.HealthFill.Visible = false
        d.HealthText = Drawing.new("Text")
        d.HealthText.Visible = false
        d.HealthText.Center = true
        d.HealthText.Outline = true
        d.HealthText.Font = Drawing.Fonts.System

        -- Armor bar
        d.ArmorOut = Drawing.new("Line")
        d.ArmorOut.Visible = false
        d.ArmorOut.Color = Color3.fromRGB(0,0,0)
        d.ArmorBG = Drawing.new("Line")
        d.ArmorBG.Visible = false
        d.ArmorFill = Drawing.new("Line")
        d.ArmorFill.Visible = false

        return d
    end

    local function Hide(d)
        for i = 1, 8 do
            d.Lines[i].Visible = false
            d.Outlines[i].Visible = false
        end
        d.Fill.Visible = false
        d.Name.Visible = false
        d.Weapon.Visible = false
        d.Flag.Visible = false
        d.HealthOut.Visible = false
        d.HealthBG.Visible = false
        d.HealthFill.Visible = false
        d.HealthText.Visible = false
        d.ArmorOut.Visible = false
        d.ArmorBG.Visible = false
        d.ArmorFill.Visible = false
    end

    local function Destroy(d)
        for i = 1, 8 do
            d.Lines[i]:Remove()
            d.Outlines[i]:Remove()
        end
        d.Fill:Remove()
        d.Name:Remove()
        d.Weapon:Remove()
        d.Flag:Remove()
        d.HealthOut:Remove()
        d.HealthBG:Remove()
        d.HealthFill:Remove()
        d.HealthText:Remove()
        d.ArmorOut:Remove()
        d.ArmorBG:Remove()
        d.ArmorFill:Remove()
    end

    local Icons = {
        db="‚ö°", rev="üî´", revolver="üî´", tactical="üí•", sg="üí®", shotgun="üí®",
        silencer="üîá", usp="üî´", katana="‚öîÔ∏è", knife="üî™", bat="üèè", fists="üëä",
        ak="üî´", m4="üî´", smg="üí®", sniper="üéØ", grenade="üí£", molotov="üî•",
        medkit="üíä", bandage="ü©π"
    }

    local function GetIcon(name)
        local lower = string.lower(name)
        for k, v in pairs(Icons) do
            if string.find(lower, k) then return v end
        end
        return "üîß"
    end

    local function Start()
        if Connection then return end
        
        Connection = RunService.RenderStepped:Connect(function(dt)
            local cfg = Config.Esp
            Tick = Tick + dt

            if not cfg.Enabled then
                for _, d in pairs(Cache) do Hide(d) end
                return
            end

            local localChar = LocalPlayer.Character
            local localRoot = localChar and localChar:FindFirstChild('HumanoidRootPart')
            local alive = {}
            local shift = (mathSin(Tick * (cfg.Boxes.RotationSpeed or 300) / 200) + 1) / 2

            for _, plr in ipairs(Players:GetPlayers()) do
                if plr == LocalPlayer then continue end
                alive[plr] = true

                local isFriend = Friends[plr.UserId] or false
                
                if cfg.FriendCheck and isFriend then
                    if Cache[plr] then Hide(Cache[plr]) end
                    continue
                end

                if cfg.TeamCheck and plr.Team == LocalPlayer.Team then
                    if Cache[plr] then Hide(Cache[plr]) end
                    continue
                end

                if not Cache[plr] then Cache[plr] = NewDraw() end
                local d = Cache[plr]
                local char = plr.Character

                if not char then Hide(d) continue end
                
                local hum = char:FindFirstChild('Humanoid')
                local root = char:FindFirstChild('HumanoidRootPart')
                
                if not hum or not root or hum.Health <= 0 then Hide(d) continue end
                if char:GetAttribute('Knocked') or char:GetAttribute('Dead') then Hide(d) continue end

                local _, onScreen = WorldToViewportPoint(Camera, root.Position)
                if not onScreen then Hide(d) continue end

                local box = GetBox(char)
                if not box then Hide(d) continue end

                local dist = localRoot and (localRoot.Position - root.Position).Magnitude or 0
                if cfg.MaxDistance > 0 and dist > cfg.MaxDistance then Hide(d) continue end

                local alpha = GetAlpha(dist, cfg.MaxDistance, cfg.FadeOutOnDistance)
                local hp = mathClamp(hum.Health / hum.MaxHealth, 0, 1)
                
                local armor = 0
                pcall(function() armor = char:GetAttribute("Armor") or 0 end)
                local armorPct = mathClamp(armor / 130, 0, 1)

                local baseCol = isFriend and cfg.FriendRGB or (cfg.Boxes.Full.RGB or Color3.fromRGB(255,255,255))
                local gradCol1 = cfg.Boxes.GradientRGB1 or baseCol
                local gradCol2 = cfg.Boxes.GradientRGB2 or baseCol
                local fontSize = cfg.FontSize or 11

                -- ‚ïê‚ïê‚ïê FILLED BOX ‚ïê‚ïê‚ïê
                if cfg.Boxes.Filled and cfg.Boxes.Filled.Enabled then
                    d.Fill.Position = box.TL
                    d.Fill.Size = Vector2New(box.W, box.H)
                    d.Fill.Color = cfg.Boxes.Filled.RGB or Color3.fromRGB(0,0,0)
                    d.Fill.Transparency = (1 - (cfg.Boxes.Filled.Transparency or 0.75)) * alpha
                    d.Fill.Visible = true
                else
                    d.Fill.Visible = false
                end

                -- ‚ïê‚ïê‚ïê BOX LINES ‚ïê‚ïê‚ïê
                local showFull = cfg.Boxes.Full and cfg.Boxes.Full.Enabled
                local showCorner = cfg.Boxes.Corner and cfg.Boxes.Corner.Enabled

                if showCorner then
                    local cl = 0.25
                    local cW, cH = box.W * cl, box.H * cl
                    local segs = {
                        {box.TL, box.TL + Vector2New(cW, 0)},
                        {box.TL, box.TL + Vector2New(0, cH)},
                        {box.TR, box.TR + Vector2New(-cW, 0)},
                        {box.TR, box.TR + Vector2New(0, cH)},
                        {box.BL, box.BL + Vector2New(cW, 0)},
                        {box.BL, box.BL + Vector2New(0, -cH)},
                        {box.BR, box.BR + Vector2New(-cW, 0)},
                        {box.BR, box.BR + Vector2New(0, -cH)},
                    }
                    for i = 1, 8 do
                        local col = baseCol
                        if cfg.Boxes.Gradient and cfg.Boxes.Animate then
                            col = LerpColor(gradCol1, gradCol2, mathSin((i/8 + shift) * math.pi * 2) * 0.5 + 0.5)
                        elseif cfg.Boxes.Gradient then
                            col = LerpColor(gradCol1, gradCol2, i/8)
                        end
                        d.Outlines[i].From = segs[i][1]
                        d.Outlines[i].To = segs[i][2]
                        d.Outlines[i].Thickness = 2.5
                        d.Outlines[i].Transparency = 0.5 * alpha
                        d.Outlines[i].Visible = true
                        d.Lines[i].From = segs[i][1]
                        d.Lines[i].To = segs[i][2]
                        d.Lines[i].Thickness = 1
                        d.Lines[i].Color = col
                        d.Lines[i].Transparency = alpha
                        d.Lines[i].Visible = true
                    end
                elseif showFull then
                    local segs = {
                        {box.TL, box.TR}, {box.TR, box.BR},
                        {box.BR, box.BL}, {box.BL, box.TL}
                    }
                    for i = 1, 4 do
                        local col = baseCol
                        if cfg.Boxes.Gradient and cfg.Boxes.Animate then
                            col = LerpColor(gradCol1, gradCol2, mathSin((i/4 + shift) * math.pi * 2) * 0.5 + 0.5)
                        elseif cfg.Boxes.Gradient then
                            col = LerpColor(gradCol1, gradCol2, i/4)
                        end
                        d.Outlines[i].From = segs[i][1]
                        d.Outlines[i].To = segs[i][2]
                        d.Outlines[i].Thickness = 2.5
                        d.Outlines[i].Transparency = 0.5 * alpha
                        d.Outlines[i].Visible = true
                        d.Lines[i].From = segs[i][1]
                        d.Lines[i].To = segs[i][2]
                        d.Lines[i].Thickness = 1
                        d.Lines[i].Color = col
                        d.Lines[i].Transparency = alpha
                        d.Lines[i].Visible = true
                    end
                    for i = 5, 8 do
                        d.Lines[i].Visible = false
                        d.Outlines[i].Visible = false
                    end
                else
                    for i = 1, 8 do
                        d.Lines[i].Visible = false
                        d.Outlines[i].Visible = false
                    end
                end

                -- ‚ïê‚ïê‚ïê NAME + DISTANCE ‚ïê‚ïê‚ïê
                if cfg.Names and cfg.Names.Enabled then
                    local name = plr.DisplayName or plr.Name
                    if cfg.Distances and cfg.Distances.Enabled and cfg.Distances.Position == "Text" then
                        local distStr = dist < 10 and string.format("%.1fm", dist) or mathFloor(dist).."m"
                        name = name .. " [" .. distStr .. "]"
                    end
                    d.Name.Text = name
                    d.Name.Position = Vector2New(box.CX, box.TY - fontSize - 3)
                    d.Name.Color = isFriend and cfg.FriendRGB or cfg.Names.RGB
                    d.Name.Size = fontSize
                    d.Name.Transparency = alpha
                    d.Name.Visible = true
                else
                    d.Name.Visible = false
                end

                -- ‚ïê‚ïê‚ïê WEAPON ‚ïê‚ïê‚ïê
                if cfg.Weapons and cfg.Weapons.Enabled then
                    local tool = char:FindFirstChildWhichIsA('Tool')
                    if tool then
                        d.Weapon.Text = GetIcon(tool.Name) .. " " .. tool.Name
                        d.Weapon.Position = Vector2New(box.CX, box.BY + 2)
                        d.Weapon.Color = cfg.Weapons.WeaponTextRGB
                        d.Weapon.Size = fontSize
                        d.Weapon.Transparency = alpha
                        d.Weapon.Visible = true
                    else
                        d.Weapon.Visible = false
                    end
                else
                    d.Weapon.Visible = false
                end

                -- ‚ïê‚ïê‚ïê FLAGS ‚ïê‚ïê‚ïê
                if cfg.Flags and cfg.Flags.Enabled and armor > 0 then
                    d.Flag.Text = "üõ°Ô∏è " .. mathFloor(armor)
                    d.Flag.Position = Vector2New(box.TR.X + 3, box.TY)
                    d.Flag.Color = Color3.fromRGB(255,255,255)
                    d.Flag.Size = fontSize - 1
                    d.Flag.Transparency = alpha
                    d.Flag.Visible = true
                else
                    d.Flag.Visible = false
                end

                -- ‚ïê‚ïê‚ïê HEALTH BAR ‚ïê‚ïê‚ïê
                if cfg.Healthbar and cfg.Healthbar.Enabled then
                    local bw = cfg.Healthbar.Width or 2.5
                    local bx = box.TL.X - 6 - bw
                    local bc = bx + bw / 2
                    local fillY = box.BY - (box.H * hp)

                    d.HealthOut.From = Vector2New(bc, box.TY - 1)
                    d.HealthOut.To = Vector2New(bc, box.BY + 1)
                    d.HealthOut.Thickness = bw + 3
                    d.HealthOut.Transparency = 0.5 * alpha
                    d.HealthOut.Visible = true

                    d.HealthBG.From = Vector2New(bc, box.TY)
                    d.HealthBG.To = Vector2New(bc, box.BY)
                    d.HealthBG.Thickness = bw + 1
                    d.HealthBG.Color = Color3.fromRGB(30,30,30)
                    d.HealthBG.Transparency = 0.3 * alpha
                    d.HealthBG.Visible = true

                    local hpCol
                    if cfg.Healthbar.Gradient then
                        hpCol = Gradient3(
                            cfg.Healthbar.GradientRGB1 or Color3.fromRGB(255,0,0),
                            cfg.Healthbar.GradientRGB2 or Color3.fromRGB(255,255,0),
                            cfg.Healthbar.GradientRGB3 or Color3.fromRGB(0,255,0),
                            hp
                        )
                    else
                        hpCol = hp > 0.5 and LerpColor(Color3.fromRGB(255,220,50), Color3.fromRGB(80,255,120), (hp-0.5)*2)
                            or LerpColor(Color3.fromRGB(255,50,60), Color3.fromRGB(255,220,50), hp*2)
                    end

                    d.HealthFill.From = Vector2New(bc, fillY)
                    d.HealthFill.To = Vector2New(bc, box.BY)
                    d.HealthFill.Thickness = bw
                    d.HealthFill.Color = hpCol
                    d.HealthFill.Transparency = alpha
                    d.HealthFill.Visible = hp > 0.001

                    if cfg.Healthbar.HealthText and hp < 1 then
                        d.HealthText.Text = tostring(mathFloor(hum.Health))
                        d.HealthText.Position = Vector2New(bc, fillY - fontSize - 2)
                        d.HealthText.Color = cfg.Healthbar.HealthTextRGB
                        d.HealthText.Size = fontSize - 1
                        d.HealthText.Transparency = alpha
                        d.HealthText.Visible = true
                    else
                        d.HealthText.Visible = false
                    end
                else
                    d.HealthOut.Visible = false
                    d.HealthBG.Visible = false
                    d.HealthFill.Visible = false
                    d.HealthText.Visible = false
                end

                -- ‚ïê‚ïê‚ïê ARMOR BAR ‚ïê‚ïê‚ïê
                if cfg.Armor and cfg.Armor.Enabled and armor > 0 then
                    local bw = cfg.Armor.BarWidth or 2.5
                    local bx = box.TR.X + 6
                    local bc = bx + bw / 2
                    local fillY = box.BY - (box.H * armorPct)

                    d.ArmorOut.From = Vector2New(bc, box.TY - 1)
                    d.ArmorOut.To = Vector2New(bc, box.BY + 1)
                    d.ArmorOut.Thickness = bw + 3
                    d.ArmorOut.Transparency = 0.5 * alpha
                    d.ArmorOut.Visible = true

                    d.ArmorBG.From = Vector2New(bc, box.TY)
                    d.ArmorBG.To = Vector2New(bc, box.BY)
                    d.ArmorBG.Thickness = bw + 1
                    d.ArmorBG.Color = Color3.fromRGB(30,30,30)
                    d.ArmorBG.Transparency = 0.3 * alpha
                    d.ArmorBG.Visible = true

                    local armorCol = armorPct >= 0.7 and cfg.Armor.HighRGB
                        or armorPct >= 0.3 and cfg.Armor.MediumRGB
                        or cfg.Armor.LowRGB

                    d.ArmorFill.From = Vector2New(bc, fillY)
                    d.ArmorFill.To = Vector2New(bc, box.BY)
                    d.ArmorFill.Thickness = bw
                    d.ArmorFill.Color = armorCol
                    d.ArmorFill.Transparency = alpha
                    d.ArmorFill.Visible = true
                else
                    d.ArmorOut.Visible = false
                    d.ArmorBG.Visible = false
                    d.ArmorFill.Visible = false
                end
            end

            -- Cleanup
            for plr, d in pairs(Cache) do
                if not alive[plr] then
                    Hide(d)
                    Destroy(d)
                    Cache[plr] = nil
                end
            end
        end)
    end

    local function Stop()
        if Connection then
            Connection:Disconnect()
            Connection = nil
        end
        for _, d in pairs(Cache) do
            Hide(d)
            Destroy(d)
        end
        Cache = {}
    end

    Players.PlayerRemoving:Connect(function(plr)
        Friends[plr.UserId] = nil
        if Cache[plr] then
            Hide(Cache[plr])
            Destroy(Cache[plr])
            Cache[plr] = nil
        end
    end)

    -- Keybind
    if Config.Esp.Use_KeyBind then
        UserInputService.InputBegan:Connect(function(input, gpe)
            if gpe then return end
            if input.KeyCode == Config.Esp.KeyBind then
                Config.Esp.Enabled = not Config.Esp.Enabled
            end
        end)
    end

    Start()

    ESP.Start = Start
    ESP.Stop = Stop
    ESP.Toggle = function() Config.Esp.Enabled = not Config.Esp.Enabled end
    ESP.Refresh = UpdateFriends
    
    return ESP
end

return CreateESP
